


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MultiWordChunker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.tagging.disambiguation</a>
</div>

<h1>Coverage Summary for Class: MultiWordChunker (org.languagetool.tagging.disambiguation)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MultiWordChunker</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.2%
  </span>
  <span class="absValue">
    (75/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (125/132)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker 
&nbsp; * Copyright (C) 2007 Daniel Naber (http://www.danielnaber.de)
&nbsp; * 
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;
&nbsp;package org.languagetool.tagging.disambiguation;
&nbsp;
&nbsp;import gnu.trove.THashMap;
&nbsp;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.AnalyzedSentence;
&nbsp;import org.languagetool.AnalyzedToken;
&nbsp;import org.languagetool.AnalyzedTokenReadings;
&nbsp;import org.languagetool.JLanguageTool;
&nbsp;import org.languagetool.tools.StringTools;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;/**
&nbsp; * Multiword tagger-chunker.
&nbsp; *
&nbsp; * @author Marcin Mi≈Çkowski
&nbsp; */
&nbsp;public class MultiWordChunker extends AbstractDisambiguator {
&nbsp;
&nbsp;  private final String filename;
&nbsp;  private final boolean allowFirstCapitalized;
&nbsp;  private final boolean allowAllUppercase;
&nbsp;
&nbsp;  private volatile boolean initialized;
&nbsp;  private Map&lt;String, Integer&gt; mStartSpace;
&nbsp;  private Map&lt;String, Integer&gt; mStartNoSpace;
&nbsp;  private Map&lt;String, AnalyzedToken&gt; mFull;
&nbsp;  
&nbsp;  private final static int MAX_TOKENS_IN_MULTIWORD = 20;
&nbsp;  
&nbsp;  private final static String DEFAULT_SEPARATOR = &quot;\t&quot;;
&nbsp;  private String separator;
&nbsp;
&nbsp;  /**
&nbsp;   * @param filename file text with multiwords and tags
&nbsp;   */
&nbsp;  public MultiWordChunker(String filename) {
<b class="nc">&nbsp;    this(filename, false, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param filename              file text with multiwords and tags
&nbsp;   * @param allowFirstCapitalized if set to {@code true}, first word of the
&nbsp;   *                              multiword can be capitalized
&nbsp;   * @param allowAllUppercase     if set to {@code true}, the all uppercase
&nbsp;   *                              version of the multiword is allowed
&nbsp;   */
<b class="fc">&nbsp;  public MultiWordChunker(String filename, boolean allowFirstCapitalized, boolean allowAllUppercase) {</b>
<b class="fc">&nbsp;    this.filename = filename;</b>
<b class="fc">&nbsp;    this.allowFirstCapitalized = allowFirstCapitalized;</b>
<b class="fc">&nbsp;    this.allowAllUppercase = allowAllUppercase;</b>
&nbsp;  }
&nbsp;
&nbsp;  /*
&nbsp;   * Lazy init, thanks to Artur Trzewik
&nbsp;   */
&nbsp;  private void lazyInit() {
<b class="fc">&nbsp;    if (initialized) {</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    synchronized (this) {</b>
<b class="fc">&nbsp;      if (initialized) return;</b>
&nbsp;
<b class="fc">&nbsp;      THashMap&lt;String, Integer&gt; mStartSpace = new THashMap&lt;&gt;();</b>
<b class="fc">&nbsp;      THashMap&lt;String, Integer&gt; mStartNoSpace = new THashMap&lt;&gt;();</b>
<b class="fc">&nbsp;      THashMap&lt;String, AnalyzedToken&gt; mFull = new THashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;      fillMaps(mStartSpace, mStartNoSpace, mFull);</b>
&nbsp;
<b class="fc">&nbsp;      mStartSpace.trimToSize();</b>
<b class="fc">&nbsp;      mStartNoSpace.trimToSize();</b>
<b class="fc">&nbsp;      mFull.trimToSize();</b>
&nbsp;
<b class="fc">&nbsp;      this.mStartSpace = mStartSpace;</b>
<b class="fc">&nbsp;      this.mStartNoSpace = mStartNoSpace;</b>
<b class="fc">&nbsp;      this.mFull = mFull;</b>
<b class="fc">&nbsp;      initialized = true;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private void fillMaps(Map&lt;String, Integer&gt; mStartSpace, Map&lt;String, Integer&gt; mStartNoSpace, Map&lt;String, AnalyzedToken&gt; mFull) {
<b class="fc">&nbsp;    Map&lt;String, String&gt; interner = new HashMap&lt;&gt;();</b>
<b class="pc">&nbsp;    try (InputStream stream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename)) {</b>
<b class="fc">&nbsp;      List&lt;String&gt; posTokens = loadWords(stream);</b>
<b class="fc">&nbsp;      for (String posToken : posTokens) {</b>
<b class="fc">&nbsp;        String[] tokenAndTag = posToken.split(separator);</b>
<b class="pc">&nbsp;        if (tokenAndTag.length != 2) {</b>
<b class="nc">&nbsp;          throw new RuntimeException(</b>
&nbsp;              &quot;Invalid format in &quot; + filename + &quot;: &#39;&quot; + posToken + &quot;&#39;, expected two tab-separated parts&quot;);
&nbsp;        }
<b class="fc">&nbsp;        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        String originalToken = interner.computeIfAbsent(tokenAndTag[0], Function.identity());</b>
<b class="fc">&nbsp;        String tag = interner.computeIfAbsent(tokenAndTag[1], Function.identity());</b>
<b class="fc">&nbsp;        tokens.add(originalToken);</b>
<b class="pc">&nbsp;        if (allowFirstCapitalized) {</b>
<b class="fc">&nbsp;          String tokenFirstCapitalized = StringTools.uppercaseFirstChar(originalToken);</b>
<b class="fc">&nbsp;          if (!mFull.containsKey(tokenFirstCapitalized) &amp;&amp; !originalToken.equals(tokenFirstCapitalized)) {</b>
<b class="fc">&nbsp;            tokens.add(tokenFirstCapitalized);</b>
&nbsp;          }
&nbsp;        }
<b class="pc">&nbsp;        if (allowAllUppercase) {</b>
<b class="fc">&nbsp;          String tokenAllUppercase = originalToken.toUpperCase();</b>
<b class="fc">&nbsp;          if (!mFull.containsKey(tokenAllUppercase) &amp;&amp; !originalToken.equals(tokenAllUppercase)) {</b>
<b class="fc">&nbsp;            tokens.add(tokenAllUppercase);</b>
&nbsp;          }
&nbsp;        }
<b class="fc">&nbsp;        for (String token : tokens) {</b>
<b class="fc">&nbsp;          boolean containsSpace = token.indexOf(&#39; &#39;) &gt; 0;</b>
&nbsp;          String firstToken;
&nbsp;          String[] firstTokens;
<b class="fc">&nbsp;          if (!containsSpace) {</b>
<b class="fc">&nbsp;            firstTokens = new String[tokenAndTag[0].length()];</b>
<b class="fc">&nbsp;            firstToken = token.substring(0, 1);</b>
<b class="fc">&nbsp;            for (int i = 1; i &lt; token.length(); i++) {</b>
<b class="fc">&nbsp;              firstTokens[i] = token.substring(i - 1, i);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (mStartNoSpace.containsKey(firstToken)) {</b>
<b class="fc">&nbsp;              if (mStartNoSpace.get(firstToken) &lt; firstTokens.length) {</b>
<b class="fc">&nbsp;                mStartNoSpace.put(firstToken, firstTokens.length);</b>
&nbsp;              }
&nbsp;            } else {
<b class="fc">&nbsp;              mStartNoSpace.put(firstToken, firstTokens.length);</b>
&nbsp;            }
&nbsp;          } else {
<b class="fc">&nbsp;            firstTokens = token.split(&quot; &quot;);</b>
<b class="fc">&nbsp;            firstToken = firstTokens[0];</b>
&nbsp;
<b class="fc">&nbsp;            if (mStartSpace.containsKey(firstToken)) {</b>
<b class="fc">&nbsp;              if (mStartSpace.get(firstToken) &lt; firstTokens.length) {</b>
<b class="fc">&nbsp;                mStartSpace.put(firstToken, firstTokens.length);</b>
&nbsp;              }
&nbsp;            } else {
<b class="fc">&nbsp;              mStartSpace.put(firstToken, firstTokens.length);</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          mFull.put(token, new AnalyzedToken(token, tag, originalToken));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;      }</b>
<b class="pc">&nbsp;    } catch (IOException e) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public AnalyzedSentence disambiguate(AnalyzedSentence input) throws IOException {
<b class="nc">&nbsp;    return disambiguate(input, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Implements multiword POS tags, e.g., &amp;lt;ELLIPSIS&amp;gt; for ellipsis (...)
&nbsp;   * start, and &amp;lt;/ELLIPSIS&amp;gt; for ellipsis end.
&nbsp;   *
&nbsp;   * @param input The tokens to be chunked.
&nbsp;   * @return AnalyzedSentence with additional markers.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public final AnalyzedSentence disambiguate(AnalyzedSentence input, @Nullable JLanguageTool.CheckCancelledCallback checkCanceled) throws IOException {
&nbsp;
<b class="fc">&nbsp;    lazyInit();</b>
&nbsp;
<b class="fc">&nbsp;    AnalyzedTokenReadings[] anTokens = input.getTokens();</b>
<b class="fc">&nbsp;    AnalyzedTokenReadings[] output = anTokens;</b>
&nbsp;
<b class="fc">&nbsp;    for (int i = 0; i &lt; anTokens.length; i++) {</b>
<b class="fc">&nbsp;      String tok = output[i].getToken();</b>
<b class="fc">&nbsp;      if (tok.length() &lt; 1) {</b>
<b class="fc">&nbsp;        continue;</b>
&nbsp;      }
&nbsp;      // If the second token is not whitespace, concatenate it
<b class="fc">&nbsp;      if (i + 1 &lt; anTokens.length &amp;&amp; !anTokens[i + 1].isWhitespace()) {</b>
<b class="fc">&nbsp;        tok = tok + output[i + 1].getToken();</b>
&nbsp;      }
&nbsp;
<b class="pc">&nbsp;      if (checkCanceled != null &amp;&amp; checkCanceled.checkCancelled()) {</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      StringBuilder tokens = new StringBuilder();</b>
<b class="fc">&nbsp;      int finalLen = 0;</b>
<b class="fc">&nbsp;      if (mStartSpace.containsKey(tok)) {</b>
<b class="fc">&nbsp;        int len = mStartSpace.get(tok);</b>
<b class="fc">&nbsp;        int j = i;</b>
<b class="fc">&nbsp;        int lenCounter = 0;</b>
<b class="pc">&nbsp;        while (j &lt; anTokens.length  &amp;&amp; j - i &lt; MAX_TOKENS_IN_MULTIWORD) {</b>
<b class="fc">&nbsp;          if (!anTokens[j].isWhitespace()) {</b>
<b class="fc">&nbsp;            tokens.append(anTokens[j].getToken());</b>
<b class="fc">&nbsp;            String toks = tokens.toString();</b>
<b class="fc">&nbsp;            if (mFull.containsKey(toks)) {</b>
<b class="fc">&nbsp;              output[i] = prepareNewReading(toks, output[i].getToken(), output[i], false);</b>
<b class="fc">&nbsp;              output[finalLen] = prepareNewReading(toks, anTokens[finalLen].getToken(), output[finalLen], true);</b>
&nbsp;            }
<b class="fc">&nbsp;          } else {</b>
<b class="pc">&nbsp;            if (j &gt; 1 &amp;&amp; !anTokens[j - 1].isWhitespace()) { // avoid multiple whitespaces</b>
<b class="fc">&nbsp;              tokens.append(&#39; &#39;);</b>
<b class="fc">&nbsp;              lenCounter++;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (lenCounter == len) {</b>
<b class="fc">&nbsp;              break;</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          j++;</b>
<b class="fc">&nbsp;          finalLen = j;</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      if (mStartNoSpace.containsKey(tok.substring(0, 1))) {</b>
<b class="fc">&nbsp;        int j = i;</b>
<b class="pc">&nbsp;        while (j &lt; anTokens.length &amp;&amp; !anTokens[j].isWhitespace() &amp;&amp; j - i &lt; MAX_TOKENS_IN_MULTIWORD) {</b>
<b class="fc">&nbsp;          tokens.append(anTokens[j].getToken());</b>
<b class="fc">&nbsp;          String toks = tokens.toString();</b>
<b class="fc">&nbsp;          if (mFull.containsKey(toks)) {</b>
<b class="fc">&nbsp;            output[i] = prepareNewReading(toks, anTokens[i].getToken(), output[i], false);</b>
<b class="fc">&nbsp;            output[j] = prepareNewReading(toks, anTokens[j].getToken(), output[j], true);</b>
&nbsp;          }
<b class="fc">&nbsp;          j++;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return new AnalyzedSentence(output);</b>
&nbsp;  }
&nbsp;
&nbsp;  private AnalyzedTokenReadings prepareNewReading(String tokens, String tok, AnalyzedTokenReadings token,
&nbsp;      boolean isLast) {
<b class="fc">&nbsp;    StringBuilder sb = new StringBuilder();</b>
<b class="fc">&nbsp;    sb.append(&#39;&lt;&#39;);</b>
<b class="fc">&nbsp;    if (isLast) {</b>
<b class="fc">&nbsp;      sb.append(&#39;/&#39;);</b>
&nbsp;    }
<b class="fc">&nbsp;    sb.append(mFull.get(tokens).getPOSTag());</b>
<b class="fc">&nbsp;    sb.append(&#39;&gt;&#39;);</b>
<b class="fc">&nbsp;    AnalyzedToken tokenStart = new AnalyzedToken(tok, sb.toString(), mFull.get(tokens).getLemma());</b>
<b class="fc">&nbsp;    return setAndAnnotate(token, tokenStart);</b>
&nbsp;  }
&nbsp;
&nbsp;  private AnalyzedTokenReadings setAndAnnotate(AnalyzedTokenReadings oldReading, AnalyzedToken newReading) {
<b class="fc">&nbsp;    AnalyzedTokenReadings newAtr = oldReading;</b>
<b class="fc">&nbsp;    newAtr.addReading(newReading, &quot;MULTIWORD_CHUNKER&quot;);</b>
<b class="fc">&nbsp;    return newAtr;</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;String&gt; loadWords(InputStream stream) {
<b class="fc">&nbsp;    List&lt;String&gt; lines = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {</b>
&nbsp;      String line;
<b class="fc">&nbsp;      separator = DEFAULT_SEPARATOR;</b>
<b class="fc">&nbsp;      while ((line = reader.readLine()) != null) {</b>
<b class="fc">&nbsp;        line = line.trim();</b>
<b class="pc">&nbsp;        if (line.startsWith(&quot;#separatorRegExp=&quot;)) {</b>
<b class="nc">&nbsp;          separator = line.replace(&quot;#separatorRegExp=&quot;, &quot;&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (line.isEmpty() || line.charAt(0) == &#39;#&#39;) { // ignore comments</b>
<b class="fc">&nbsp;          continue;</b>
&nbsp;        }
<b class="fc">&nbsp;        line = StringUtils.substringBefore(line, &quot;#&quot;).trim();</b>
<b class="fc">&nbsp;        lines.add(line);</b>
&nbsp;      }
<b class="fc">&nbsp;    } catch (IOException e) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return lines;</b>
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-20 19:41</div>
</div>
</body>
</html>
