


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > PronomFebleDuplicateRule</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules.ca</a>
</div>

<h1>Coverage Summary for Class: PronomFebleDuplicateRule (org.languagetool.rules.ca)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PronomFebleDuplicateRule</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/94)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.languagetool.rules.ca;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.ResourceBundle;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import org.languagetool.AnalyzedSentence;
&nbsp;import org.languagetool.AnalyzedToken;
&nbsp;import org.languagetool.AnalyzedTokenReadings;
&nbsp;import org.languagetool.rules.Category;
&nbsp;import org.languagetool.rules.CategoryId;
&nbsp;import org.languagetool.rules.Example;
&nbsp;import org.languagetool.rules.ITSIssueType;
&nbsp;import org.languagetool.rules.Rule;
&nbsp;import org.languagetool.rules.RuleMatch;
&nbsp;import org.languagetool.tools.StringTools;
&nbsp;
&nbsp;public class PronomFebleDuplicateRule extends Rule {
&nbsp;
&nbsp;  // tots els pronoms febles
<b class="nc">&nbsp;  private static final Pattern PRONOM_FEBLE = Pattern.compile(&quot;P0.{6}|PP3CN000|PP3NN000|PP3..A00|PP3CP000|PP3CSD00&quot;);</b>
<b class="nc">&nbsp;  private static final Pattern VERB_CONJUGAT = Pattern.compile(&quot;V.[IS].*&quot;);</b>
<b class="nc">&nbsp;  private static final Pattern INFINITIU = Pattern.compile(&quot;V.N.*&quot;);</b>
<b class="nc">&nbsp;  private static final Pattern PARTICIPI = Pattern.compile(&quot;V.P..SM.&quot;);</b>
<b class="nc">&nbsp;  private static final Pattern GERUNDI = Pattern.compile(&quot;V.G.*&quot;);</b>
<b class="nc">&nbsp;  private static final String[] ABANS_DE_GERUNDI = { &quot;continuar&quot;, &quot;seguir&quot;, &quot;prosseguir&quot;, &quot;anar&quot;, &quot;estar&quot;, &quot;acabar&quot; };</b>
<b class="nc">&nbsp;  private static final String[] ABANS_DE_INFINITIU = { &quot;anar&quot;, &quot;poder&quot;, &quot;voler&quot;, &quot;deure&quot; };</b>
<b class="nc">&nbsp;  private static final String[] ABANS_DE_A = { &quot;començar&quot;, &quot;tornar&quot; }; //&quot;ajudar&quot;, &quot;atrevir&quot; , &quot;acostumar&quot;</b>
&nbsp;  //private static final String[] VERBS_IMPERSONAL = new String[] { &quot;ordenar&quot;, &quot;recomanar&quot; };
&nbsp;
&nbsp;  @Override
&nbsp;  public String getId() {
<b class="nc">&nbsp;    return &quot;PRONOMS_FEBLES_DUPLICATS&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String getDescription() {
<b class="nc">&nbsp;    return &quot;Pronoms febles duplicats&quot;;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public PronomFebleDuplicateRule(ResourceBundle messages) throws IOException {</b>
<b class="nc">&nbsp;    super.setCategory(new Category(new CategoryId(&quot;PRONOMS_FEBLES&quot;), &quot;Pronoms febles&quot;));</b>
<b class="nc">&nbsp;    setLocQualityIssueType(ITSIssueType.Grammar);</b>
<b class="nc">&nbsp;    addExamplePair(Example.wrong(&quot;&lt;marker&gt;S&#39;ha de fer-se&lt;/marker&gt;.&quot;), Example.fixed(&quot;&lt;marker&gt;S&#39;ha de fer&lt;/marker&gt;.&quot;));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
<b class="nc">&nbsp;    final List&lt;RuleMatch&gt; ruleMatches = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    final AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();</b>
<b class="nc">&nbsp;    String PFLemma = &quot;&quot;;</b>
<b class="nc">&nbsp;    int initPos = -1;</b>
<b class="nc">&nbsp;    boolean isPrevInfinitive = false;</b>
<b class="nc">&nbsp;    for (int i = 1; i &lt; tokens.length; i++) { // ignoring token 0, i.e., SENT_START</b>
<b class="nc">&nbsp;      if (PFLemma.isEmpty()) {</b>
<b class="nc">&nbsp;        PFLemma = getLemmaOfPronomFeble(tokens[i]);</b>
&nbsp;        // exception: Es recomana, S&#39;ordena
&nbsp;        /*if (i + 1 &lt; tokens.length &amp;&amp; PFLemma.equalsIgnoreCase(&quot;es&quot;) &amp;&amp; tokens[i + 1].hasAnyLemma(VERBS_IMPERSONAL)) {
&nbsp;          PFLemma = &quot;&quot;;
&nbsp;          initPos = -1;
&nbsp;          continue;
&nbsp;        }*/
<b class="nc">&nbsp;        if (i &gt; 1 &amp;&amp; !tokens[i].isWhitespaceBefore()) {</b>
<b class="nc">&nbsp;          PFLemma = &quot;&quot;;</b>
<b class="nc">&nbsp;          initPos = -1;</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!PFLemma.isEmpty()) {</b>
<b class="nc">&nbsp;          initPos = i;</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        String PFLemma2 = getLemmaOfPronomFeble(tokens[i]);</b>
<b class="nc">&nbsp;        if (!tokens[i].isWhitespaceBefore() &amp;&amp; PFLemma2.equals(PFLemma) &amp;&amp; isPrevInfinitive) {</b>
&nbsp;          // Rule matches!
<b class="nc">&nbsp;          final RuleMatch ruleMatch = new RuleMatch(this, sentence, tokens[initPos].getStartPos(),</b>
<b class="nc">&nbsp;              tokens[i].getEndPos(), &quot;Pronom feble duplicat. Elimineu-ne un.&quot;, &quot;Pronom feble duplicat&quot;);</b>
&nbsp;          // first suggestion
<b class="nc">&nbsp;          StringBuilder suggestion = new StringBuilder();</b>
<b class="nc">&nbsp;          for (int j = initPos + 1; j &lt;= i; j++) {</b>
<b class="nc">&nbsp;            if (j &gt; initPos + 1 &amp;&amp; tokens[j].isWhitespaceBefore()) {</b>
<b class="nc">&nbsp;              suggestion.append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            String strToAdd = tokens[j].getToken();</b>
<b class="nc">&nbsp;            if (j == initPos + 1 &amp;&amp; StringTools.isCapitalizedWord(tokens[initPos].getToken())) {</b>
<b class="nc">&nbsp;              strToAdd = StringTools.uppercaseFirstChar(strToAdd);</b>
&nbsp;            }
<b class="nc">&nbsp;            suggestion.append(strToAdd);</b>
&nbsp;          }
<b class="nc">&nbsp;          ruleMatch.addSuggestedReplacement(suggestion.toString());</b>
&nbsp;          // second suggestion
<b class="nc">&nbsp;          suggestion = new StringBuilder();</b>
<b class="nc">&nbsp;          for (int j = initPos; j &lt;= i - 1; j++) {</b>
<b class="nc">&nbsp;            if (j &gt; initPos &amp;&amp; tokens[j].isWhitespaceBefore()) {</b>
<b class="nc">&nbsp;              suggestion.append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            suggestion.append(tokens[j].getToken());</b>
&nbsp;          }
<b class="nc">&nbsp;          ruleMatch.addSuggestedReplacement(suggestion.toString());</b>
<b class="nc">&nbsp;          ruleMatches.add(ruleMatch);</b>
<b class="nc">&nbsp;        } else if (!tokens[i].isWhitespaceBefore() &amp;&amp; isPrevInfinitive</b>
<b class="nc">&nbsp;            &amp;&amp; (PFLemma.equals(&quot;en&quot;) &amp;&amp; PFLemma2.equals(&quot;hi&quot;) || PFLemma.equals(&quot;hi&quot;) &amp;&amp; PFLemma2.equals(&quot;en&quot;))) {</b>
<b class="nc">&nbsp;          final RuleMatch ruleMatch = new RuleMatch(this, sentence, tokens[initPos].getStartPos(),</b>
<b class="nc">&nbsp;              tokens[i].getEndPos(), &quot;Combinació de pronoms febles probablement incorrecta&quot;,</b>
&nbsp;              &quot;Pronoms febles incorrectes&quot;);
<b class="nc">&nbsp;          ruleMatches.add(ruleMatch);</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;
<b class="nc">&nbsp;          isPrevInfinitive = matchPostagRegexp(tokens[i], INFINITIU)</b>
<b class="nc">&nbsp;              || (matchPostagRegexp(tokens[i], GERUNDI) &amp;&amp; tokens[i - 1].hasAnyLemma(ABANS_DE_GERUNDI));</b>
&nbsp;
&nbsp;          // check whether to keep checking
<b class="nc">&nbsp;          if (!keepChecking(tokens, i, initPos)) {</b>
<b class="nc">&nbsp;            PFLemma = &quot;&quot;;</b>
<b class="nc">&nbsp;            initPos = -1;</b>
&nbsp;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;    }
<b class="nc">&nbsp;    return toRuleMatchArray(ruleMatches);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean keepChecking(AnalyzedTokenReadings[] tokens, int i, int initPos) {
<b class="nc">&nbsp;    if (i == initPos + 1) {</b>
<b class="nc">&nbsp;      return matchPostagRegexp(tokens[i], VERB_CONJUGAT);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (tokens[i].hasLemma(&quot;de&quot;)) {</b>
<b class="nc">&nbsp;      return tokens[i - 1].hasLemma(&quot;haver&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (tokens[i].hasLemma(&quot;a&quot;)) {</b>
<b class="nc">&nbsp;      return tokens[i - 1].hasAnyLemma(ABANS_DE_A);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (matchPostagRegexp(tokens[i], PARTICIPI)) {</b>
<b class="nc">&nbsp;      return tokens[i - 1].hasLemma(&quot;haver&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (matchPostagRegexp(tokens[i], GERUNDI)) {</b>
<b class="nc">&nbsp;      return tokens[i - 1].hasAnyLemma(ABANS_DE_GERUNDI);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (matchPostagRegexp(tokens[i], INFINITIU)) {</b>
<b class="nc">&nbsp;      return tokens[i - 1].hasAnyLemma(ABANS_DE_INFINITIU) || tokens[i - 1].hasLemma(&quot;de&quot;) || tokens[i - 1].hasLemma(&quot;a&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String getLemmaOfPronomFeble(AnalyzedTokenReadings aToken) {
<b class="nc">&nbsp;    for (AnalyzedToken analyzedToken : aToken) {</b>
<b class="nc">&nbsp;      String posTag = analyzedToken.getPOSTag();</b>
<b class="nc">&nbsp;      if (posTag == null) {</b>
<b class="nc">&nbsp;        posTag = &quot;UNKNOWN&quot;;</b>
&nbsp;      }
<b class="nc">&nbsp;      final Matcher m = PRONOM_FEBLE.matcher(posTag);</b>
<b class="nc">&nbsp;      if (m.matches()) {</b>
<b class="nc">&nbsp;        return analyzedToken.getLemma();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean matchPostagRegexp(AnalyzedTokenReadings aToken, Pattern pattern) {
<b class="nc">&nbsp;    boolean matches = false;</b>
<b class="nc">&nbsp;    for (AnalyzedToken analyzedToken : aToken) {</b>
<b class="nc">&nbsp;      String posTag = analyzedToken.getPOSTag();</b>
<b class="nc">&nbsp;      if (posTag == null) {</b>
<b class="nc">&nbsp;        posTag = &quot;UNKNOWN&quot;;</b>
&nbsp;      }
<b class="nc">&nbsp;      final Matcher m = pattern.matcher(posTag);</b>
<b class="nc">&nbsp;      if (m.matches()) {</b>
<b class="nc">&nbsp;        matches = true;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return matches;</b>
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-20 19:41</div>
</div>
</body>
</html>
