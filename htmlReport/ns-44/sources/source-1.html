


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MorfologikMultiSpeller</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules.spelling.morfologik</a>
</div>

<h1>Coverage Summary for Class: MorfologikMultiSpeller (org.languagetool.rules.spelling.morfologik)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MorfologikMultiSpeller</td>
<td class="coverageStat">
  <span class="percent">
    73.7%
  </span>
  <span class="absValue">
    (14/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57%
  </span>
  <span class="absValue">
    (49/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.5%
  </span>
  <span class="absValue">
    (103/146)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MorfologikMultiSpeller$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MorfologikMultiSpeller$BufferedReaderWithSource</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MorfologikMultiSpeller$UserDictCacheKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    72.4%
  </span>
  <span class="absValue">
    (21/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (60/108)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.2%
  </span>
  <span class="absValue">
    (125/186)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker
&nbsp; * Copyright (C) 2015 Daniel Naber (http://www.danielnaber.de)
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;package org.languagetool.rules.spelling.morfologik;
&nbsp;
&nbsp;import com.google.common.cache.*;
&nbsp;import morfologik.fsa.FSA;
&nbsp;import morfologik.fsa.builders.CFSA2Serializer;
&nbsp;import morfologik.fsa.builders.FSABuilder;
&nbsp;import morfologik.stemming.Dictionary;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.apache.commons.lang3.builder.EqualsBuilder;
&nbsp;import org.apache.commons.lang3.builder.HashCodeBuilder;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.UserConfig;
&nbsp;import org.languagetool.rules.spelling.SpellingCheckRule;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import static java.nio.charset.StandardCharsets.UTF_8;
&nbsp;import static org.languagetool.JLanguageTool.DICTIONARY_FILENAME_EXTENSION;
&nbsp;import static org.languagetool.JLanguageTool.getDataBroker;
&nbsp;import morfologik.fsa.FSA;
&nbsp;import morfologik.fsa.builders.CFSA2Serializer;
&nbsp;import morfologik.fsa.builders.FSABuilder;
&nbsp;import morfologik.stemming.Dictionary;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Morfologik speller that merges results from binary (.dict) and plain text (.txt) dictionaries.
&nbsp; *
&nbsp; * @since 2.9
&nbsp; */
&nbsp;public class MorfologikMultiSpeller {
&nbsp;
&nbsp;  private static class UserDictCacheKey {
&nbsp;
&nbsp;    private final long userId;
&nbsp;    private final String binaryDictPath;
&nbsp;
<b class="nc">&nbsp;    UserDictCacheKey(long userId, String binaryDictPath) {</b>
<b class="nc">&nbsp;      this.userId = userId;</b>
<b class="nc">&nbsp;      this.binaryDictPath = binaryDictPath;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="nc">&nbsp;      if (this == o) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      UserDictCacheKey that = (UserDictCacheKey) o;</b>
&nbsp;
<b class="nc">&nbsp;      return new EqualsBuilder()</b>
<b class="nc">&nbsp;        .append(userId, that.userId)</b>
<b class="nc">&nbsp;        .append(binaryDictPath, that.binaryDictPath)</b>
<b class="nc">&nbsp;        .isEquals();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;      return new HashCodeBuilder(43, 57)</b>
<b class="nc">&nbsp;        .append(userId)</b>
<b class="nc">&nbsp;        .append(binaryDictPath)</b>
<b class="nc">&nbsp;        .toHashCode();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private static final Logger logger = LoggerFactory.getLogger(MorfologikMultiSpeller.class);</b>
&nbsp;
<b class="fc">&nbsp;  private static final LoadingCache&lt;BufferedReaderWithSource, List&lt;byte[]&gt;&gt; dictCache = CacheBuilder.newBuilder()</b>
&nbsp;          //.maximumSize(0)
<b class="fc">&nbsp;          .expireAfterWrite(10, TimeUnit.MINUTES)</b>
<b class="fc">&nbsp;          .build(new CacheLoader&lt;BufferedReaderWithSource, List&lt;byte[]&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public List&lt;byte[]&gt; load(@NotNull BufferedReaderWithSource reader) throws IOException {
<b class="fc">&nbsp;              List&lt;byte[]&gt; lines = getLines(reader.reader, reader.readerPath);</b>
<b class="fc">&nbsp;              if (reader.languageVariantReader != null) {</b>
<b class="fc">&nbsp;                lines.addAll(getLines(reader.languageVariantReader, reader.readerPath));</b>
<b class="fc">&nbsp;                lines.add(SpellingCheckRule.LANGUAGETOOL.getBytes());  // adding here so it&#39;s also used for suggestions</b>
&nbsp;              }
<b class="fc">&nbsp;              return lines;</b>
&nbsp;            }
&nbsp;
&nbsp;            private List&lt;byte[]&gt; getLines(BufferedReader br, String path) throws IOException {
<b class="fc">&nbsp;              List&lt;byte[]&gt; lines = new ArrayList&lt;&gt;();</b>
&nbsp;              String line;
<b class="fc">&nbsp;              while ((line = br.readLine()) != null) {</b>
<b class="fc">&nbsp;                if (!line.startsWith(&quot;#&quot;)) {</b>
<b class="fc">&nbsp;                  lines.add(StringUtils.substringBefore(line,&quot;#&quot;).trim().getBytes(UTF_8));</b>
&nbsp;                }
&nbsp;              }
<b class="fc">&nbsp;              return lines;</b>
&nbsp;            }
&nbsp;          });
<b class="fc">&nbsp;  private static final Map&lt;String,Dictionary&gt; dicPathToDict = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;  private static final Map&lt;UserDictCacheKey, Cache&lt;String, Dictionary&gt;&gt; userDictCaches = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;  private static final Map&lt;UserDictCacheKey, Map&lt;String, Integer&gt;&gt; userDictSizes = new HashMap&lt;&gt;();</b>
&nbsp;  private final List&lt;MorfologikSpeller&gt; spellers;
&nbsp;  private final List&lt;MorfologikSpeller&gt; defaultDictSpellers;
&nbsp;  private final List&lt;MorfologikSpeller&gt; userDictSpellers;
&nbsp;  private final boolean convertsCase;
&nbsp;  private final Long premiumUid;
&nbsp;  private final Long userDictCacheSize;
&nbsp;  private final String userDictName;
&nbsp;  private final UserDictCacheKey userDictCacheKey;
&nbsp;  private static final int MAX_SUGGESTIONS = 20;
&nbsp;
&nbsp;  public MorfologikMultiSpeller(String binaryDictPath, List&lt;String&gt; plainTextPaths, String languageVariantPlainTextPath, int maxEditDistance) throws IOException {
<b class="nc">&nbsp;    this(binaryDictPath, plainTextPaths, languageVariantPlainTextPath, null, maxEditDistance);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param binaryDictPath path in classpath to a {@code .dict} binary Morfologik file
&nbsp;   * @param plainTextPaths paths in classpath to plain text {@code .txt} files (like spelling.txt)
&nbsp;   * @param maxEditDistance maximum edit distance for accepting suggestions
&nbsp;   * @since 4.2
&nbsp;   */
&nbsp;  public MorfologikMultiSpeller(String binaryDictPath, List&lt;String&gt; plainTextPaths, String languageVariantPlainTextPath,
&nbsp;    UserConfig userConfig, int maxEditDistance) throws IOException {
<b class="fc">&nbsp;    this(binaryDictPath,</b>
<b class="fc">&nbsp;         getBufferedReader(plainTextPaths),</b>
&nbsp;         plainTextPaths,
<b class="fc">&nbsp;         languageVariantPlainTextPath == null ? null : new BufferedReader(new InputStreamReader(getDataBroker().getFromResourceDirAsStream(languageVariantPlainTextPath), UTF_8)),</b>
&nbsp;         languageVariantPlainTextPath,
&nbsp;         userConfig, maxEditDistance);
<b class="fc">&nbsp;    for (String plainTextPath : plainTextPaths) {</b>
<b class="pc">&nbsp;      if (plainTextPath != null &amp;&amp;</b>
<b class="pc">&nbsp;        (!plainTextPath.endsWith(&quot;.txt&quot;) ||</b>
<b class="pc">&nbsp;          (languageVariantPlainTextPath != null &amp;&amp; !languageVariantPlainTextPath.endsWith(&quot;.txt&quot;)))) {</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Unsupported dictionary, plain text file needs to have suffix .txt: &quot; + plainTextPath);</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  @NotNull
&nbsp;  private static BufferedReader getBufferedReader(List&lt;String&gt; plainTextPaths) {
<b class="fc">&nbsp;    List&lt;InputStream&gt; streams = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (String plainTextPath : plainTextPaths) {</b>
<b class="fc">&nbsp;      streams.add(getDataBroker().getFromResourceDirAsStream(plainTextPath));</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return new BufferedReader(new InputStreamReader(new SequenceInputStream(Collections.enumeration(streams)), UTF_8));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param binaryDictPath path in classpath to a {@code .dict} binary Morfologik file
&nbsp;   * @param plainTextReader reader with to a plain text {@code .txt} file (like from spelling.txt)
&nbsp;   * @param userConfig
&nbsp;   * @param maxEditDistance maximum edit distance for accepting suggestions
&nbsp;   * @since 3.0
&nbsp;   */
&nbsp;  public MorfologikMultiSpeller(String binaryDictPath, BufferedReader plainTextReader, List&lt;String&gt; plainTextReaderPath,
&nbsp;                                BufferedReader languageVariantPlainTextReader, String languageVariantPlainTextPath, UserConfig userConfig,
<b class="fc">&nbsp;                                int maxEditDistance) throws IOException {</b>
<b class="pc">&nbsp;    if (userConfig == null || userConfig.getAcceptedWords() == null || userConfig.getAcceptedWords().isEmpty()) {</b>
<b class="fc">&nbsp;      premiumUid = null;</b>
<b class="fc">&nbsp;      userDictName = null;</b>
<b class="fc">&nbsp;      userDictCacheSize = null;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      premiumUid = userConfig.getPremiumUid();</b>
<b class="fc">&nbsp;      userDictName = userConfig.getUserDictName();</b>
<b class="fc">&nbsp;      userDictCacheSize = userConfig.getUserDictCacheSize();</b>
&nbsp;    }
<b class="pc">&nbsp;    if (premiumUid != null &amp;&amp; userDictCacheSize != null) {</b>
<b class="nc">&nbsp;      userDictCacheKey = new UserDictCacheKey(premiumUid, binaryDictPath);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      userDictCacheKey = null;</b>
&nbsp;    }
<b class="fc">&nbsp;    MorfologikSpeller speller = getBinaryDict(binaryDictPath, maxEditDistance);</b>
<b class="fc">&nbsp;    List&lt;MorfologikSpeller&gt; spellers = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    MorfologikSpeller userDictSpeller = getUserDictSpellerOrNull(userConfig, binaryDictPath, maxEditDistance);</b>
<b class="pc">&nbsp;    if (userDictSpeller != null) {</b>
&nbsp;      // add this first, as otherwise suggestions from user&#39;s own dictionary might drown in the mass of other suggestions
<b class="nc">&nbsp;      spellers.add(userDictSpeller);</b>
<b class="nc">&nbsp;      userDictSpellers = Collections.singletonList(userDictSpeller);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      userDictSpellers = Collections.emptyList();</b>
&nbsp;    }
<b class="fc">&nbsp;    spellers.add(speller);</b>
<b class="fc">&nbsp;    convertsCase = speller.convertsCase();</b>
<b class="pc">&nbsp;    if (plainTextReader != null) {</b>
<b class="fc">&nbsp;      MorfologikSpeller plainTextSpeller = getPlainTextDictSpellerOrNull(plainTextReader, plainTextReaderPath,</b>
&nbsp;        languageVariantPlainTextReader, languageVariantPlainTextPath, binaryDictPath, maxEditDistance);
<b class="pc">&nbsp;      if (plainTextSpeller != null) {</b>
<b class="fc">&nbsp;        spellers.add(plainTextSpeller);</b>
<b class="fc">&nbsp;        defaultDictSpellers = Arrays.asList(speller, plainTextSpeller);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        defaultDictSpellers = Collections.singletonList(speller);</b>
&nbsp;      }
<b class="fc">&nbsp;    } else {</b>
<b class="nc">&nbsp;      defaultDictSpellers = Collections.singletonList(speller);</b>
&nbsp;    }
<b class="fc">&nbsp;    this.spellers = Collections.unmodifiableList(spellers);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static List&lt;byte[]&gt; getLines(BufferedReader br) throws IOException {
<b class="nc">&nbsp;    List&lt;byte[]&gt; lines = new ArrayList&lt;&gt;();</b>
&nbsp;    String line;
<b class="nc">&nbsp;    while ((line = br.readLine()) != null) {</b>
<b class="nc">&nbsp;      if (!line.startsWith(&quot;#&quot;)) {</b>
<b class="nc">&nbsp;        lines.add(line.replaceFirst(&quot;#.*&quot;, &quot;&quot;).trim().getBytes(&quot;utf-8&quot;));</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return lines;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Cache&lt;String, Dictionary&gt; getUserDictCache() {
<b class="nc">&nbsp;    if (premiumUid == null || userDictCacheSize == null || userDictName == null) {</b>
<b class="nc">&nbsp;      throw new IllegalStateException(&quot;No user / dict caching / dict name configured: &quot;</b>
&nbsp;        + &quot;user = &quot; + premiumUid +  &quot;, cache size = &quot; + userDictCacheSize + &quot;, dict name = &quot; + userDictName);
&nbsp;    }
<b class="nc">&nbsp;    if (userDictCaches.containsKey(userDictCacheKey)) {</b>
<b class="nc">&nbsp;      return userDictCaches.get(userDictCacheKey);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      Cache&lt;String, Dictionary&gt; cache = CacheBuilder.newBuilder()</b>
<b class="nc">&nbsp;        .concurrencyLevel(1) // makes eviction behavior easier to understand, makes choosing maximumWeight easier</b>
<b class="nc">&nbsp;        .expireAfterWrite(10, TimeUnit.MINUTES)</b>
<b class="nc">&nbsp;        .maximumWeight(userDictCacheSize)</b>
<b class="nc">&nbsp;        .weigher((Weigher&lt;String, Dictionary&gt;) (k, v) -&gt; userDictSizes.get(userDictCacheKey).get(k))</b>
<b class="nc">&nbsp;        .build();</b>
<b class="nc">&nbsp;      userDictCaches.put(userDictCacheKey, cache);</b>
<b class="nc">&nbsp;      return cache;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private MorfologikSpeller getUserDictSpellerOrNull(UserConfig userConfig, String dictPath, int maxEditDistance) throws IOException {
<b class="pc">&nbsp;    if (premiumUid == null) {</b>
<b class="fc">&nbsp;      return null;</b>
&nbsp;    }
<b class="nc">&nbsp;    List&lt;byte[]&gt; byteLines = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    for (String line : userConfig.getAcceptedWords()) {</b>
<b class="nc">&nbsp;      byteLines.add(line.getBytes(UTF_8));</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    Dictionary dictionary = getDictionary(byteLines, dictPath, dictPath.replace(DICTIONARY_FILENAME_EXTENSION, &quot;.info&quot;), true);</b>
<b class="nc">&nbsp;    return new MorfologikSpeller(dictionary, maxEditDistance);</b>
&nbsp;  }
&nbsp;
&nbsp;  private MorfologikSpeller getBinaryDict(String binaryDictPath, int maxEditDistance) {
<b class="pc">&nbsp;    if (binaryDictPath.endsWith(DICTIONARY_FILENAME_EXTENSION)) {</b>
<b class="fc">&nbsp;      return new MorfologikSpeller(binaryDictPath, maxEditDistance);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new IllegalArgumentException(&quot;Unsupported dictionary, binary Morfologik file needs to have suffix .dict: &quot; + binaryDictPath);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private MorfologikSpeller getPlainTextDictSpellerOrNull(BufferedReader plainTextReader, List&lt;String&gt; plainTextReaderPaths,
&nbsp;      BufferedReader languageVariantPlainTextReader, String languageVariantPlainTextPath, String dictPath, int maxEditDistance) throws IOException {
<b class="fc">&nbsp;    List&lt;byte[]&gt; lines = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (String plainTextReaderPath : plainTextReaderPaths) {</b>
<b class="fc">&nbsp;      List&lt;byte[]&gt; l = dictCache.getUnchecked(new BufferedReaderWithSource(plainTextReader, plainTextReaderPath, languageVariantPlainTextReader, languageVariantPlainTextPath));</b>
<b class="fc">&nbsp;      lines.addAll(l);</b>
<b class="fc">&nbsp;    }</b>
<b class="pc">&nbsp;    if (lines.isEmpty()) {</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
<b class="fc">&nbsp;    Dictionary dictionary = getDictionary(lines, plainTextReaderPaths.toString(), dictPath.replace(DICTIONARY_FILENAME_EXTENSION, &quot;.info&quot;), false);</b>
<b class="fc">&nbsp;    return new MorfologikSpeller(dictionary, maxEditDistance);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Dictionary getDictionary(List&lt;byte[]&gt; lines, String dictPath, String infoPath, boolean isUserDict) throws IOException {
<b class="fc">&nbsp;    String cacheKey = dictPath + &quot;|&quot; + infoPath;</b>
<b class="fc">&nbsp;    Dictionary dictFromCache = dicPathToDict.get(cacheKey);</b>
&nbsp;
<b class="pc">&nbsp;    if (!isUserDict &amp;&amp; dictFromCache != null) {</b>
<b class="fc">&nbsp;      return dictFromCache;</b>
&nbsp;    } else {
<b class="pc">&nbsp;      if (isUserDict &amp;&amp; userDictCacheSize != null) {</b>
&nbsp;        // for cache weigher, save dictionary sizes
<b class="nc">&nbsp;        userDictSizes.putIfAbsent(userDictCacheKey, new HashMap&lt;&gt;());</b>
<b class="nc">&nbsp;        userDictSizes.get(userDictCacheKey).put(userDictName, lines.size());</b>
<b class="nc">&nbsp;        Cache&lt;String, Dictionary&gt; userDictCache = getUserDictCache();</b>
<b class="nc">&nbsp;        Dictionary userDict = userDictCache.getIfPresent(userDictName);</b>
<b class="nc">&nbsp;        if (userDict != null) {</b>
<b class="nc">&nbsp;          return userDict;</b>
&nbsp;        }
&nbsp;      }
&nbsp;      // Creating the dictionary at runtime can easily take 50ms for spelling.txt files
&nbsp;      // that are ~50KB. We don&#39;t want that overhead for every check of a short sentence,
&nbsp;      // so we cache the result
&nbsp;      // Two caches exist: One for the standard dictionaries, which are static and in dicPathToDict
&nbsp;      // Another one for user dictionaries, this is only enabled for selected users with huge and relatively static dictionaries
&nbsp;
<b class="fc">&nbsp;      List&lt;byte[]&gt; linesCopy = new ArrayList&lt;&gt;(lines);</b>
<b class="fc">&nbsp;      linesCopy.sort(FSABuilder.LEXICAL_ORDERING);</b>
<b class="fc">&nbsp;      FSA fsa = FSABuilder.build(linesCopy);</b>
<b class="fc">&nbsp;      ByteArrayOutputStream fsaOutStream = new CFSA2Serializer().serialize(fsa, new ByteArrayOutputStream());</b>
<b class="fc">&nbsp;      ByteArrayInputStream fsaInStream = new ByteArrayInputStream(fsaOutStream.toByteArray());</b>
&nbsp;      InputStream metadata;
&nbsp;
<b class="fc">&nbsp;      if (new File(infoPath).exists()) {</b>
<b class="fc">&nbsp;        metadata = new FileInputStream(infoPath);</b>
&nbsp;      } else {
<b class="fc">&nbsp;        metadata = getDataBroker().getFromResourceDirAsStream(infoPath);</b>
&nbsp;      }
<b class="fc">&nbsp;      Dictionary dict = Dictionary.read(fsaInStream, metadata);</b>
&nbsp;
<b class="pc">&nbsp;      if (!isUserDict) {</b>
<b class="fc">&nbsp;        dicPathToDict.put(cacheKey, dict);</b>
<b class="nc">&nbsp;      } else if(userDictCacheSize != null){</b>
<b class="nc">&nbsp;        getUserDictCache().put(userDictName, dict);</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      return dict;</b>
&nbsp;    }
&nbsp;  }
&nbsp;  
&nbsp;  /**
&nbsp;   * Accept the word if at least one of the dictionaries accepts it as not misspelled.
&nbsp;   */
&nbsp;  public boolean isMisspelled(String word) {
<b class="fc">&nbsp;    for (MorfologikSpeller speller : spellers) {</b>
<b class="fc">&nbsp;      if (!speller.isMisspelled(word)) {</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;  
&nbsp;  /**
&nbsp;   * Get the frequency of use of a word (0-27) form the dictionary
&nbsp;   */
&nbsp;  public int getFrequency(String word) {
<b class="fc">&nbsp;    for (MorfologikSpeller speller : spellers) {</b>
<b class="fc">&nbsp;      int freq = speller.getFrequency(word);</b>
<b class="fc">&nbsp;      if (freq &gt; 0) {</b>
<b class="fc">&nbsp;        return freq;</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  @NotNull
&nbsp;  private List&lt;String&gt; getSuggestionsFromSpellers(String word, List&lt;MorfologikSpeller&gt; spellerList) {
<b class="fc">&nbsp;    List&lt;WeightedSuggestion&gt; result = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    Set&lt;String&gt; seenWords = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    for (MorfologikSpeller speller : spellerList) {</b>
<b class="fc">&nbsp;      List&lt;WeightedSuggestion&gt; suggestions = speller.getSuggestions(word);</b>
<b class="fc">&nbsp;      for (WeightedSuggestion suggestion : suggestions) {</b>
<b class="pc">&nbsp;        if (!seenWords.contains(suggestion.getWord()) &amp;&amp; !suggestion.getWord().equals(word)) {</b>
<b class="fc">&nbsp;          result.add(suggestion);</b>
&nbsp;        }
<b class="fc">&nbsp;        seenWords.add(suggestion.getWord());</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    Collections.sort(result);</b>
<b class="fc">&nbsp;    List&lt;String&gt; wordResults = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (WeightedSuggestion weightedSuggestion : result) {</b>
<b class="fc">&nbsp;      wordResults.add(weightedSuggestion.getWord());</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return wordResults;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The suggestions from all dictionaries (without duplicates).
&nbsp;   */
&nbsp;  public List&lt;String&gt; getSuggestions(String word) {
<b class="nc">&nbsp;    return getSuggestionsFromSpellers(word, spellers);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param word misspelled word
&nbsp;   * @return suggestions from users personal dictionary
&nbsp;   * @since 4.5
&nbsp;   */
&nbsp;  public List&lt;String&gt; getSuggestionsFromUserDicts(String word) {
<b class="fc">&nbsp;    return getSuggestionsFromSpellers(word, userDictSpellers);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param word misspelled word
&nbsp;   * @return suggestions from built-in dictionaries
&nbsp;   * @since 4.5
&nbsp;   */
&nbsp;  public List&lt;String&gt; getSuggestionsFromDefaultDicts(String word) {
<b class="fc">&nbsp;    return getSuggestionsFromSpellers(word, defaultDictSpellers);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Determines whether the dictionary uses case conversions.
&nbsp;   * @return True when the speller uses spell conversions.
&nbsp;   * @since 2.5
&nbsp;   */
&nbsp;  public boolean convertsCase() {
<b class="fc">&nbsp;    return convertsCase;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  static class BufferedReaderWithSource {</b>
&nbsp;    private final BufferedReader reader;
&nbsp;    private final String readerPath;
&nbsp;    private final BufferedReader languageVariantReader;
&nbsp;    private final String languageVariantPath;
&nbsp;
<b class="fc">&nbsp;    BufferedReaderWithSource(BufferedReader reader, String readerPath, BufferedReader languageVariantReader, String languageVariantPath) {</b>
<b class="fc">&nbsp;      this.reader = Objects.requireNonNull(reader);</b>
<b class="fc">&nbsp;      this.readerPath = Objects.requireNonNull(readerPath);</b>
<b class="fc">&nbsp;      this.languageVariantReader = languageVariantReader;</b>
<b class="fc">&nbsp;      this.languageVariantPath = languageVariantPath;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="pc">&nbsp;      if (this == o) {</b>
<b class="nc">&nbsp;        return true;</b>
<b class="pc">&nbsp;      } else if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="fc">&nbsp;      BufferedReaderWithSource that = (BufferedReaderWithSource) o;</b>
<b class="pc">&nbsp;      return Objects.equals(readerPath, that.readerPath) &amp;&amp; Objects.equals(languageVariantPath, that.languageVariantPath);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;      return Objects.hash(readerPath, languageVariantPath);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * for tests only
&nbsp;   */
&nbsp;  public static void clearUserDictCache() {
<b class="nc">&nbsp;    userDictCaches.clear();</b>
<b class="nc">&nbsp;    userDictSizes.clear();</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-20 19:41</div>
</div>
</body>
</html>
