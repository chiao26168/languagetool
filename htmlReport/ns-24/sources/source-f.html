


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AbstractSimpleReplaceRule2</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules</a>
</div>

<h1>Coverage Summary for Class: AbstractSimpleReplaceRule2 (org.languagetool.rules)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractSimpleReplaceRule2</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.2%
  </span>
  <span class="absValue">
    (58/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.1%
  </span>
  <span class="absValue">
    (103/127)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractSimpleReplaceRule2$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractSimpleReplaceRule2$CaseSensitivy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractSimpleReplaceRule2$PathsAndLanguage</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (18/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.9%
  </span>
  <span class="absValue">
    (66/112)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.4%
  </span>
  <span class="absValue">
    (121/145)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker 
&nbsp; * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)
&nbsp; * 
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;package org.languagetool.rules;
&nbsp;
&nbsp;import com.google.common.cache.CacheBuilder;
&nbsp;import com.google.common.cache.CacheLoader;
&nbsp;import com.google.common.cache.LoadingCache;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.languagetool.AnalyzedSentence;
&nbsp;import org.languagetool.AnalyzedTokenReadings;
&nbsp;import org.languagetool.Language;
&nbsp;import org.languagetool.tools.StringTools;
&nbsp;import org.languagetool.tools.Tools;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.ArrayBlockingQueue;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import static org.languagetool.JLanguageTool.getDataBroker;
&nbsp;
&nbsp;/**
&nbsp; * A rule that matches words which should not be used and suggests correct ones instead. 
&nbsp; * &lt;p&gt;Unlike AbstractSimpleReplaceRule, it supports phrases (Ex: &quot;aqua forte&quot; -&amp;gt; &quot;acvaforte&quot;).
&nbsp; * Note: Merge this into {@link AbstractSimpleReplaceRule}
&nbsp; *
&nbsp; * @author Ionuț Păduraru
&nbsp; */
<b class="fc">&nbsp;public abstract class AbstractSimpleReplaceRule2 extends Rule {</b>
&nbsp;
<b class="fc">&nbsp;  public enum CaseSensitivy {CS, CI, CSExceptAtSentenceStart}</b>
&nbsp;
&nbsp;  private final Language language;
&nbsp;
&nbsp;  protected boolean subRuleSpecificIds;
&nbsp;  
&nbsp;  public abstract List&lt;String&gt; getFileNames();
&nbsp;  @Override
&nbsp;  public abstract String getId();
&nbsp;  @Override
&nbsp;  public abstract String getDescription();
&nbsp;  public abstract String getShort();
&nbsp;
&nbsp;  /**
&nbsp;   * @return A string where {@code $match} will be replaced with the matching word
&nbsp;   * and {@code $suggestions} will be replaced with the alternatives. This is the string
&nbsp;   * shown to the user.
&nbsp;   */
&nbsp;  public abstract String getMessage();
&nbsp;
&nbsp;  /**
&nbsp;   * @return the word used to separate multiple suggestions; used only before last suggestion, the rest are comma-separated.  
&nbsp;   */
&nbsp;  public String getSuggestionsSeparator() {
<b class="nc">&nbsp;    return &quot;, &quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * locale used on case-conversion
&nbsp;   */
&nbsp;  public abstract Locale getLocale();
&nbsp;
<b class="fc">&nbsp;  private static final LoadingCache&lt;PathsAndLanguage, List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt;&gt; cache = CacheBuilder.newBuilder()</b>
<b class="fc">&nbsp;          .expireAfterWrite(30, TimeUnit.MINUTES)</b>
<b class="fc">&nbsp;          .build(new CacheLoader&lt;PathsAndLanguage, List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; load(@NotNull PathsAndLanguage lap) throws IOException {
<b class="fc">&nbsp;              List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; maps = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;              for (String path : lap.paths) {</b>
<b class="fc">&nbsp;                List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; l = loadWords(path, lap.lang, lap.caseSensitive, lap.checkingCase);</b>
<b class="fc">&nbsp;                maps.addAll(l);</b>
<b class="fc">&nbsp;              }</b>
<b class="fc">&nbsp;              return maps;</b>
&nbsp;            }
&nbsp;          });
&nbsp;
&nbsp;  public AbstractSimpleReplaceRule2(ResourceBundle messages, Language language) {
<b class="fc">&nbsp;    super(messages);</b>
<b class="fc">&nbsp;    this.language = Objects.requireNonNull(language);</b>
<b class="fc">&nbsp;    super.setCategory(Categories.MISC.getCategory(messages));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * If this is set, each replacement pair will have its own rule ID, making rule deactivations more specific.
&nbsp;   * @since 5.1
&nbsp;   */
&nbsp;  public void useSubRuleSpecificIds() {
<b class="fc">&nbsp;    subRuleSpecificIds = true;</b>
&nbsp;  }
&nbsp;  
&nbsp;  public CaseSensitivy getCaseSensitivy() {
<b class="fc">&nbsp;    return CaseSensitivy.CI;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return the list of wrong words for which this rule can suggest corrections. The list cannot be modified.
&nbsp;   */
&nbsp;  public List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; getWrongWords(boolean checkingCase) {
&nbsp;    try {
<b class="pc">&nbsp;      boolean caseSen = getCaseSensitivy() == CaseSensitivy.CS || getCaseSensitivy() == CaseSensitivy.CSExceptAtSentenceStart;</b>
<b class="fc">&nbsp;      return cache.get(new PathsAndLanguage(getFileNames(), language, caseSen, checkingCase));</b>
<b class="nc">&nbsp;    } catch (ExecutionException e) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Load the list of words.
&nbsp;   * Same as {@link AbstractSimpleReplaceRule#loadFromPath} but allows multiple words and a custom message (optional).
&nbsp;   * @param filename the file from classpath to load
&nbsp;   * @return the list of maps containing the error-corrections pairs. The n-th map contains key strings of (n+1) words.
&nbsp;   */
&nbsp;  private static List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; loadWords(String filename, Language lang, boolean caseSensitive, boolean checkingCase)
&nbsp;          throws IOException {
<b class="fc">&nbsp;    List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; list = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    InputStream stream = getDataBroker().getFromRulesDirAsStream(filename);</b>
<b class="nc">&nbsp;    try (</b>
<b class="fc">&nbsp;      InputStreamReader isr = new InputStreamReader(stream, StandardCharsets.UTF_8);</b>
<b class="fc">&nbsp;      BufferedReader br = new BufferedReader(isr)) </b>
&nbsp;    {
&nbsp;      String line;
<b class="fc">&nbsp;      while ((line = br.readLine()) != null) {</b>
<b class="fc">&nbsp;        line = line.trim();</b>
<b class="fc">&nbsp;        if (line.isEmpty() || line.charAt(0) == &#39;#&#39;) { // ignore comments</b>
<b class="fc">&nbsp;          continue;</b>
&nbsp;        }
<b class="pc">&nbsp;        if (checkingCase) {</b>
<b class="nc">&nbsp;          String[] parts = line.split(&quot;=&quot;);</b>
<b class="nc">&nbsp;          line = parts[0].toLowerCase().trim() + &quot;=&quot; + parts[0].trim();</b>
<b class="nc">&nbsp;          if (parts.length == 2) {</b>
<b class="nc">&nbsp;            line = line + &quot;\t&quot; + parts[1].trim();</b>
&nbsp;          } 
&nbsp;        }
<b class="fc">&nbsp;        String[] parts = line.split(&quot;\t&quot;);</b>
<b class="fc">&nbsp;        String confPair = parts[0];</b>
&nbsp;        String msg;
<b class="fc">&nbsp;        if (parts.length == 1) {</b>
<b class="fc">&nbsp;          msg = null;</b>
<b class="pc">&nbsp;        } else if (parts.length == 2) {</b>
<b class="fc">&nbsp;          msg = parts[1];</b>
&nbsp;        } else {
<b class="nc">&nbsp;          throw new IOException(&quot;Format error in file &quot; + getDataBroker().getFromRulesDirAsUrl(filename)</b>
&nbsp;            + &quot;. Expected at most 1 &#39;=&#39; character and at most 1 tab character. Line: &quot; + line);
&nbsp;        }
<b class="fc">&nbsp;        String[] confPairParts = confPair.split(&quot;=&quot;);</b>
<b class="fc">&nbsp;        String[] wrongForms = confPairParts[0].split(&quot;\\|&quot;); // multiple incorrect forms</b>
<b class="fc">&nbsp;        for (String wrongForm : wrongForms) {</b>
<b class="fc">&nbsp;          int wordCount = getWordCount(lang, wrongForm);</b>
<b class="fc">&nbsp;          for (int i = list.size(); i &lt; wordCount; i++) {  // grow if necessary</b>
<b class="fc">&nbsp;            list.add(new HashMap&lt;&gt;());</b>
&nbsp;          }
<b class="pc">&nbsp;          String searchToken = caseSensitive ? wrongForm : wrongForm.toLowerCase();</b>
<b class="pc">&nbsp;          if (!checkingCase &amp;&amp; searchToken.equals(confPairParts[1])) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Format error in file &quot; +  getDataBroker().getFromRulesDirAsUrl(filename)</b>
&nbsp;              + &quot;. Found same word on left and right side of &#39;=&#39;. Line: &quot; + line);
&nbsp;          }
<b class="fc">&nbsp;          SuggestionWithMessage sugg = new SuggestionWithMessage(confPairParts[1], msg);</b>
<b class="fc">&nbsp;          list.get(wordCount - 1).put(searchToken, sugg);</b>
&nbsp;        }
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;    // seal the result (prevent modification from outside this class)
<b class="fc">&nbsp;    List&lt;Map&lt;String,SuggestionWithMessage&gt;&gt; result = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (Map&lt;String, SuggestionWithMessage&gt; map : list) {</b>
<b class="fc">&nbsp;      result.add(Collections.unmodifiableMap(map));</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return Collections.unmodifiableList(result);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int getWordCount(Language lang, String wrongForm) {
<b class="fc">&nbsp;    int wordCount = 0;</b>
<b class="fc">&nbsp;    List&lt;String&gt; tokens = lang.getWordTokenizer().tokenize(wrongForm);</b>
<b class="fc">&nbsp;    for (String token : tokens) {</b>
<b class="fc">&nbsp;      if (!StringTools.isWhitespace(token)) {</b>
<b class="fc">&nbsp;        wordCount++;</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return wordCount;</b>
&nbsp;  }
&nbsp;
&nbsp;  protected void addToQueue(AnalyzedTokenReadings token,
&nbsp;                          Queue&lt;AnalyzedTokenReadings&gt; prevTokens) {
<b class="fc">&nbsp;    boolean inserted = prevTokens.offer(token);</b>
<b class="fc">&nbsp;    if (!inserted) {</b>
<b class="fc">&nbsp;      prevTokens.poll();</b>
<b class="fc">&nbsp;      prevTokens.offer(token);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Used if each input form the replacement file has its specific id.
&nbsp;   */
&nbsp;  public String getDescription(String details) {
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public RuleMatch[] match(AnalyzedSentence sentence) {
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; ruleMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();</b>
&nbsp;
<b class="fc">&nbsp;    List&lt;Map&lt;String, SuggestionWithMessage&gt;&gt; wrongWords = getWrongWords(false);</b>
<b class="pc">&nbsp;    if (wrongWords.size() == 0) {</b>
<b class="nc">&nbsp;      return toRuleMatchArray(ruleMatches);</b>
&nbsp;    }
<b class="fc">&nbsp;    Queue&lt;AnalyzedTokenReadings&gt; prevTokens = new ArrayBlockingQueue&lt;&gt;(wrongWords.size());</b>
&nbsp;
<b class="fc">&nbsp;    for (int i = 1; i &lt; tokens.length; i++) {</b>
<b class="fc">&nbsp;      addToQueue(tokens[i], prevTokens);</b>
<b class="fc">&nbsp;      StringBuilder sb = new StringBuilder();</b>
<b class="fc">&nbsp;      List&lt;String&gt; variants = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;AnalyzedTokenReadings&gt; prevTokensList =</b>
<b class="fc">&nbsp;              Arrays.asList(prevTokens.toArray(new AnalyzedTokenReadings[0]));</b>
<b class="fc">&nbsp;      for (int j = prevTokensList.size() - 1; j &gt;= 0; j--) {</b>
<b class="fc">&nbsp;        if (j != prevTokensList.size() - 1 &amp;&amp; prevTokensList.get(j + 1).isWhitespaceBefore()) {</b>
<b class="fc">&nbsp;          sb.insert(0, &quot; &quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        sb.insert(0, prevTokensList.get(j).getToken());</b>
<b class="fc">&nbsp;        variants.add(0, sb.toString());</b>
&nbsp;      }
<b class="pc">&nbsp;      if (isTokenException(tokens[i])) {</b>
<b class="nc">&nbsp;        continue;</b>
&nbsp;      }
<b class="fc">&nbsp;      int len = variants.size(); // prevTokensList and variants have now the same length</b>
<b class="fc">&nbsp;      for (int j = 0; j &lt; len; j++) { // longest words first</b>
<b class="fc">&nbsp;        String crt = variants.get(j);</b>
<b class="fc">&nbsp;        int crtWordCount = len - j;</b>
&nbsp;        SuggestionWithMessage crtMatch;
<b class="pc">&nbsp;        if (getCaseSensitivy() == CaseSensitivy.CSExceptAtSentenceStart &amp;&amp; i - crtWordCount == 0) {  // at sentence start, words can be uppercase</b>
<b class="nc">&nbsp;          crtMatch = wrongWords.get(crtWordCount - 1).get(crt.toLowerCase(getLocale()));</b>
&nbsp;        } else {
<b class="pc">&nbsp;          boolean caseSen = getCaseSensitivy() == CaseSensitivy.CS || getCaseSensitivy() == CaseSensitivy.CSExceptAtSentenceStart;</b>
<b class="pc">&nbsp;          crtMatch = caseSen ?</b>
<b class="nc">&nbsp;            wrongWords.get(crtWordCount - 1).get(crt) :</b>
<b class="fc">&nbsp;            wrongWords.get(crtWordCount - 1).get(crt.toLowerCase(getLocale()));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (crtMatch != null) {</b>
<b class="fc">&nbsp;          List&lt;String&gt; replacements = Arrays.asList(crtMatch.getSuggestion().split(&quot;\\|&quot;));</b>
<b class="fc">&nbsp;          String msgSuggestions = &quot;&quot;;</b>
<b class="fc">&nbsp;          for (int k = 0; k &lt; replacements.size(); k++) {</b>
<b class="pc">&nbsp;            if (k &gt; 0) {</b>
<b class="nc">&nbsp;              msgSuggestions += (k == replacements.size() - 1 ? getSuggestionsSeparator(): &quot;, &quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            msgSuggestions += &quot;&lt;suggestion&gt;&quot; + replacements.get(k) + &quot;&lt;/suggestion&gt;&quot;;</b>
&nbsp;          }
<b class="fc">&nbsp;          String msg = getMessage().replaceFirst(&quot;\\$match&quot;, crt).replaceFirst(&quot;\\$suggestions&quot;, msgSuggestions);</b>
<b class="pc">&nbsp;          if (crtMatch.getMessage() != null) {</b>
<b class="nc">&nbsp;            if (!crtMatch.getMessage().startsWith(&quot;http://&quot;) &amp;&amp; !crtMatch.getMessage().startsWith(&quot;https://&quot;)) {</b>
<b class="nc">&nbsp;              msg = crtMatch.getMessage();</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          int startPos = prevTokensList.get(len - crtWordCount).getStartPos();</b>
<b class="fc">&nbsp;          int endPos = prevTokensList.get(len - 1).getEndPos();</b>
<b class="fc">&nbsp;          RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, endPos, msg, getShort());</b>
<b class="pc">&nbsp;          if (crtMatch.getMessage() != null &amp;&amp; (crtMatch.getMessage().startsWith(&quot;http://&quot;) || crtMatch.getMessage().startsWith(&quot;https://&quot;))) {</b>
<b class="nc">&nbsp;            ruleMatch.setUrl(Tools.getUrl(crtMatch.getMessage()));</b>
&nbsp;          }
<b class="pc">&nbsp;          if (subRuleSpecificIds) {</b>
<b class="nc">&nbsp;            ruleMatch.setSpecificRuleId(StringTools.toId(getId() + &quot;_&quot; + crt));</b>
&nbsp;          }
<b class="pc">&nbsp;          if ((getCaseSensitivy() != CaseSensitivy.CS || getCaseSensitivy() == CaseSensitivy.CSExceptAtSentenceStart)</b>
<b class="fc">&nbsp;               &amp;&amp; StringTools.startsWithUppercase(crt)) {</b>
<b class="fc">&nbsp;            for (int k = 0; k &lt; replacements.size(); k++) {</b>
<b class="fc">&nbsp;              replacements.set(k, StringTools.uppercaseFirstChar(replacements.get(k)));</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          ruleMatch.setSuggestedReplacements(replacements);</b>
<b class="pc">&nbsp;          if (!isException(sentence.getText().substring(startPos, endPos))) {</b>
&nbsp;            //keep only the longest match
<b class="pc">&nbsp;            if (ruleMatches.size() &gt; 0) {</b>
<b class="nc">&nbsp;              RuleMatch lastRuleMatch = ruleMatches.get(ruleMatches.size() - 1);</b>
<b class="nc">&nbsp;              if (lastRuleMatch.getFromPos() == ruleMatch.getFromPos()</b>
<b class="nc">&nbsp;                  &amp;&amp; lastRuleMatch.getToPos() &lt; ruleMatch.getToPos()) {</b>
<b class="nc">&nbsp;                ruleMatches.remove(ruleMatches.size() - 1);</b>
&nbsp;              }
&nbsp;            }
<b class="fc">&nbsp;            ruleMatches.add(ruleMatch);</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return toRuleMatchArray(ruleMatches);</b>
&nbsp;  }
&nbsp;
&nbsp;  protected boolean isException(String matchedText) {
<b class="fc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;  
&nbsp;  protected boolean isTokenException(AnalyzedTokenReadings atr) {
<b class="fc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  static class PathsAndLanguage {
&nbsp;    final List&lt;String&gt; paths;
&nbsp;    final Language lang;
&nbsp;    final boolean caseSensitive;
&nbsp;    final boolean checkingCase;
&nbsp;
<b class="fc">&nbsp;    PathsAndLanguage(List&lt;String&gt; fileNames, Language language, boolean caseSensitive, boolean checkingCase) {</b>
<b class="fc">&nbsp;      this.paths = Objects.requireNonNull(fileNames);</b>
<b class="fc">&nbsp;      this.lang = Objects.requireNonNull(language);</b>
<b class="fc">&nbsp;      this.caseSensitive = caseSensitive;</b>
<b class="fc">&nbsp;      this.checkingCase = checkingCase;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="pc">&nbsp;      if (this == o) return true;</b>
<b class="pc">&nbsp;      if (o == null || getClass() != o.getClass()) return false;</b>
<b class="fc">&nbsp;      PathsAndLanguage that = (PathsAndLanguage) o;</b>
<b class="pc">&nbsp;      return paths.equals(that.paths) &amp;&amp; lang.equals(that.lang) &amp;&amp; caseSensitive == that.caseSensitive;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;      return Objects.hash(paths, lang, caseSensitive);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-20 19:41</div>
</div>
</body>
</html>
